// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package product

import (
	"context"
	"sync"
	"tlkm-api/internal/model/product"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			CreateProductFunc: func(ctx context.Context, req product.Product) (product.Product, error) {
//				panic("mock out the CreateProduct method")
//			},
//			GetProductBySKUFunc: func(ctx context.Context, sku string) (product.Product, error) {
//				panic("mock out the GetProductBySKU method")
//			},
//			GetProductsByParamFunc: func(ctx context.Context, param product.ParamSearch) ([]product.SearchProductData, error) {
//				panic("mock out the GetProductsByParam method")
//			},
//			UpdateProductFunc: func(ctx context.Context, sku string, req product.UpdateProductRequest) (product.Product, error) {
//				panic("mock out the UpdateProduct method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// CreateProductFunc mocks the CreateProduct method.
	CreateProductFunc func(ctx context.Context, req product.Product) (product.Product, error)

	// GetProductBySKUFunc mocks the GetProductBySKU method.
	GetProductBySKUFunc func(ctx context.Context, sku string) (product.Product, error)

	// GetProductsByParamFunc mocks the GetProductsByParam method.
	GetProductsByParamFunc func(ctx context.Context, param product.ParamSearch) ([]product.SearchProductData, error)

	// UpdateProductFunc mocks the UpdateProduct method.
	UpdateProductFunc func(ctx context.Context, sku string, req product.UpdateProductRequest) (product.Product, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateProduct holds details about calls to the CreateProduct method.
		CreateProduct []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req product.Product
		}
		// GetProductBySKU holds details about calls to the GetProductBySKU method.
		GetProductBySKU []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sku is the sku argument value.
			Sku string
		}
		// GetProductsByParam holds details about calls to the GetProductsByParam method.
		GetProductsByParam []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Param is the param argument value.
			Param product.ParamSearch
		}
		// UpdateProduct holds details about calls to the UpdateProduct method.
		UpdateProduct []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sku is the sku argument value.
			Sku string
			// Req is the req argument value.
			Req product.UpdateProductRequest
		}
	}
	lockCreateProduct      sync.RWMutex
	lockGetProductBySKU    sync.RWMutex
	lockGetProductsByParam sync.RWMutex
	lockUpdateProduct      sync.RWMutex
}

// CreateProduct calls CreateProductFunc.
func (mock *RepositoryMock) CreateProduct(ctx context.Context, req product.Product) (product.Product, error) {
	if mock.CreateProductFunc == nil {
		panic("RepositoryMock.CreateProductFunc: method is nil but Repository.CreateProduct was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req product.Product
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreateProduct.Lock()
	mock.calls.CreateProduct = append(mock.calls.CreateProduct, callInfo)
	mock.lockCreateProduct.Unlock()
	return mock.CreateProductFunc(ctx, req)
}

// CreateProductCalls gets all the calls that were made to CreateProduct.
// Check the length with:
//
//	len(mockedRepository.CreateProductCalls())
func (mock *RepositoryMock) CreateProductCalls() []struct {
	Ctx context.Context
	Req product.Product
} {
	var calls []struct {
		Ctx context.Context
		Req product.Product
	}
	mock.lockCreateProduct.RLock()
	calls = mock.calls.CreateProduct
	mock.lockCreateProduct.RUnlock()
	return calls
}

// GetProductBySKU calls GetProductBySKUFunc.
func (mock *RepositoryMock) GetProductBySKU(ctx context.Context, sku string) (product.Product, error) {
	if mock.GetProductBySKUFunc == nil {
		panic("RepositoryMock.GetProductBySKUFunc: method is nil but Repository.GetProductBySKU was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sku string
	}{
		Ctx: ctx,
		Sku: sku,
	}
	mock.lockGetProductBySKU.Lock()
	mock.calls.GetProductBySKU = append(mock.calls.GetProductBySKU, callInfo)
	mock.lockGetProductBySKU.Unlock()
	return mock.GetProductBySKUFunc(ctx, sku)
}

// GetProductBySKUCalls gets all the calls that were made to GetProductBySKU.
// Check the length with:
//
//	len(mockedRepository.GetProductBySKUCalls())
func (mock *RepositoryMock) GetProductBySKUCalls() []struct {
	Ctx context.Context
	Sku string
} {
	var calls []struct {
		Ctx context.Context
		Sku string
	}
	mock.lockGetProductBySKU.RLock()
	calls = mock.calls.GetProductBySKU
	mock.lockGetProductBySKU.RUnlock()
	return calls
}

// GetProductsByParam calls GetProductsByParamFunc.
func (mock *RepositoryMock) GetProductsByParam(ctx context.Context, param product.ParamSearch) ([]product.SearchProductData, error) {
	if mock.GetProductsByParamFunc == nil {
		panic("RepositoryMock.GetProductsByParamFunc: method is nil but Repository.GetProductsByParam was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Param product.ParamSearch
	}{
		Ctx:   ctx,
		Param: param,
	}
	mock.lockGetProductsByParam.Lock()
	mock.calls.GetProductsByParam = append(mock.calls.GetProductsByParam, callInfo)
	mock.lockGetProductsByParam.Unlock()
	return mock.GetProductsByParamFunc(ctx, param)
}

// GetProductsByParamCalls gets all the calls that were made to GetProductsByParam.
// Check the length with:
//
//	len(mockedRepository.GetProductsByParamCalls())
func (mock *RepositoryMock) GetProductsByParamCalls() []struct {
	Ctx   context.Context
	Param product.ParamSearch
} {
	var calls []struct {
		Ctx   context.Context
		Param product.ParamSearch
	}
	mock.lockGetProductsByParam.RLock()
	calls = mock.calls.GetProductsByParam
	mock.lockGetProductsByParam.RUnlock()
	return calls
}

// UpdateProduct calls UpdateProductFunc.
func (mock *RepositoryMock) UpdateProduct(ctx context.Context, sku string, req product.UpdateProductRequest) (product.Product, error) {
	if mock.UpdateProductFunc == nil {
		panic("RepositoryMock.UpdateProductFunc: method is nil but Repository.UpdateProduct was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sku string
		Req product.UpdateProductRequest
	}{
		Ctx: ctx,
		Sku: sku,
		Req: req,
	}
	mock.lockUpdateProduct.Lock()
	mock.calls.UpdateProduct = append(mock.calls.UpdateProduct, callInfo)
	mock.lockUpdateProduct.Unlock()
	return mock.UpdateProductFunc(ctx, sku, req)
}

// UpdateProductCalls gets all the calls that were made to UpdateProduct.
// Check the length with:
//
//	len(mockedRepository.UpdateProductCalls())
func (mock *RepositoryMock) UpdateProductCalls() []struct {
	Ctx context.Context
	Sku string
	Req product.UpdateProductRequest
} {
	var calls []struct {
		Ctx context.Context
		Sku string
		Req product.UpdateProductRequest
	}
	mock.lockUpdateProduct.RLock()
	calls = mock.calls.UpdateProduct
	mock.lockUpdateProduct.RUnlock()
	return calls
}
